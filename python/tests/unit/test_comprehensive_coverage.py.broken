"""
Simplified comprehensive tests for core modules to achieve 95%+ coverage.

This module contains extensive tests that cover all missing lines 
in each module to reach the 95% coverage target.
"""

import asyncio
import pytest
from decimal import Decimal
from unittest.mock import Mock, AsyncMock, patch, MagicMock, call
from typing import List, Dict, Any, Optional

from solders.keypair import Keypair
from solders.pubkey import Pubkey

# Import all modules to test
from solana_ai_registries.agent import AgentRegistry
from solana_ai_registries.mcp import MCPRegistry
from solana_ai_registries.payments import PaymentManager
from solana_ai_registries.client import SolanaAIRegistriesClient
from solana_ai_registries.idl import IDLManager
from solana_ai_registries.types import (
    AgentRegistryEntry, AgentStatus, MCPServerEntry, 
    MCPServerStatus, ServiceEndpoint, AgentSkill,
    MCPTool, MCPResource, MCPPrompt, MCPCapabilities, PaymentFlowType
)
from solana_ai_registries.exceptions import (
    RegistrationError, InvalidInputError, PaymentError,
    SolanaAIRegistriesError,
    AgentExistsError, AgentNotFoundError, MCPServerExistsError,
    MCPServerNotFoundError, NetworkError
)
from solana_ai_registries.constants import (
    MAX_AGENT_ID_LEN, MAX_AGENT_NAME_LEN, MAX_AGENT_DESCRIPTION_LEN
)


class TestComprehensiveAgentCoverage:
    """Comprehensive tests for agent.py to reach 95% coverage."""
    
    def setup_method(self):
        """Setup test fixtures."""
        self.mock_client = Mock(spec=SolanaAIRegistriesClient)
        self.mock_client.client = AsyncMock()
        self.mock_client.build_register_agent_instruction = Mock()
        self.mock_client.build_update_agent_instruction = Mock()
        self.mock_client.build_deregister_agent_instruction = Mock()
        self.mock_client.send_transaction = AsyncMock(return_value="mock_signature")
        self.mock_client.get_account_info = AsyncMock()
        self.mock_client.get_multiple_accounts = AsyncMock()
        self.mock_client.derive_agent_pda = Mock(return_value=Pubkey("11111111111111111111111111111112"))
        
        self.owner = Keypair()
        self.agent_registry = AgentRegistry(self.mock_client)
        
    @pytest.mark.asyncio
    async def test_register_agent_metadata_uri_validation(self):
        """Test metadata URI validation in register_agent (line 87)."""
        # This should trigger the validate_url call on line 87
        with pytest.raises(ValidationError):
            await self.agent_registry.register_agent(
                agent_id="test",
                name="Test Agent",
                description="Test",
                owner=self.owner,
                metadata_uri="invalid-url-no-protocol"
            )
            
    @pytest.mark.asyncio
    async def test_register_agent_already_exists_error(self):
        """Test agent already exists error path (lines 90-94)."""
        # Mock existing agent found
        mock_agent = AgentRegistryEntry(
            agent_id="existing",
            name="Existing Agent",
            description="Test agent",
            owner=self.owner.pubkey(),
            status=AgentStatus.ACTIVE
        )
        
        # Mock account exists
        self.mock_client.get_account_info.return_value = Mock(value=Mock(data=b"mock_data"))
        
        with patch.object(self.agent_registry, '_deserialize_agent_data', return_value=mock_agent):
            with pytest.raises(RegistrationError, match="already exists"):
                await self.agent_registry.register_agent(
                    agent_id="existing",
                    name="Test Agent",
                    description="Test",
                    owner=self.owner
                )
                
    @pytest.mark.asyncio
    async def test_register_agent_transaction_error(self):
        """Test transaction failure in register_agent (lines 110-113)."""
        # Mock no existing agent
        self.mock_client.get_account_info.return_value = Mock(value=None)
        
        # Mock transaction failure
        self.mock_client.send_transaction.side_effect = Exception("Transaction failed")
        
        with pytest.raises(RegistrationError, match="Failed to register agent"):
            await self.agent_registry.register_agent(
                agent_id="test",
                name="Test Agent",
                description="Test",
                owner=self.owner
            )
            
    @pytest.mark.asyncio
    async def test_update_agent_not_found_error(self):
        """Test agent not found error in update_agent (lines 145-148)."""
        # Mock agent not found
        self.mock_client.get_account_info.return_value = Mock(value=None)
        
        with pytest.raises(RegistrationError, match="Agent not found"):
            await self.agent_registry.update_agent(
                agent_id="nonexistent",
                owner=self.owner,
                name="New Name"
            )
            
    @pytest.mark.asyncio
    async def test_update_agent_transaction_error(self):
        """Test transaction failure in update_agent (lines 167-174)."""
        # Mock existing agent
        mock_agent = AgentRegistryEntry(
            agent_id="test",
            name="Test Agent",
            description="Test",
            owner=self.owner.pubkey(),
            status=AgentStatus.ACTIVE
        )
        self.mock_client.get_account_info.return_value = Mock(value=Mock(data=b"mock_data"))
        
        # Mock transaction failure
        self.mock_client.send_transaction.side_effect = Exception("Update failed")
        
        with patch.object(self.agent_registry, '_deserialize_agent_data', return_value=mock_agent):
            with pytest.raises(SolanaAIRegistriesError, match="Failed to update agent"):
                await self.agent_registry.update_agent(
                    agent_id="test",
                    owner=self.owner,
                    name="New Name"
                )
                
    @pytest.mark.asyncio
    async def test_get_agent_deserialization_error(self):
        """Test deserialization error in get_agent (lines 197, 203-213)."""
        # Mock account data exists but deserialization fails
        self.mock_client.get_account_info.return_value = Mock(value=Mock(data=b"invalid_data"))
        
        with patch.object(self.agent_registry, '_deserialize_agent_data', side_effect=Exception("Deserialize failed")):
            result = await self.agent_registry.get_agent("test", self.owner.pubkey())
            assert result is None
            
    @pytest.mark.asyncio
    async def test_deregister_agent_transaction_error(self):
        """Test transaction failure in deregister_agent (lines 252-268)."""
        # Mock existing agent
        mock_agent = AgentRegistryEntry(
            agent_id="test",
            name="Test Agent",
            description="Test",
            owner=self.owner.pubkey(),
            status=AgentStatus.ACTIVE
        )
        self.mock_client.get_account_info.return_value = Mock(value=Mock(data=b"mock_data"))
        
        # Mock transaction failure
        self.mock_client.send_transaction.side_effect = Exception("Deregister failed")
        
        with patch.object(self.agent_registry, '_deserialize_agent_data', return_value=mock_agent):
            with pytest.raises(SolanaAIRegistriesError, match="Failed to deregister agent"):
                await self.agent_registry.deregister_agent(
                    agent_id="test",
                    owner=self.owner
                )
                
    @pytest.mark.asyncio
    async def test_list_agents_rpc_error(self):
        """Test RPC error handling in list_agents_by_owner (lines 294-296)."""
        # Mock RPC error
        self.mock_client.get_multiple_accounts.side_effect = Exception("RPC failed")
        
        with pytest.raises(Exception, match="RPC failed"):
            await self.agent_registry.list_agents_by_owner(self.owner.pubkey())
            
    @pytest.mark.asyncio
    async def test_search_agents_rpc_error(self):
        """Test RPC error handling in search_agents (lines 328-330)."""
        # Mock RPC error
        self.mock_client.get_multiple_accounts.side_effect = Exception("Search RPC failed")
        
        with pytest.raises(Exception):
            await self.agent_registry.search_agents(name="test")
            
    @pytest.mark.asyncio
    async def test_deserialize_agent_data_error(self):
        """Test _deserialize_agent_data error handling (line 349)."""
        # Test with invalid data that causes deserialization error
        with pytest.raises(Exception):
            self.agent_registry._deserialize_agent_data(b"invalid_data")


class TestComprehensiveMCPCoverage:
    """Comprehensive tests for mcp.py to reach 95% coverage."""
    
    def setup_method(self):
        """Setup test fixtures."""
        self.mock_client = Mock(spec=SolanaAIRegistriesClient)
        self.mock_client.client = AsyncMock()
        self.mock_client.build_register_mcp_server_instruction = Mock()
        self.mock_client.build_update_mcp_server_instruction = Mock()
        self.mock_client.build_deregister_mcp_server_instruction = Mock()
        self.mock_client.send_transaction = AsyncMock(return_value="mock_signature")
        self.mock_client.get_account_info = AsyncMock()
        self.mock_client.get_multiple_accounts = AsyncMock()
        self.mock_client.derive_mcp_server_pda = Mock(return_value=Pubkey("11111111111111111111111111111112"))
        
        self.owner = Keypair()
        self.mcp_registry = McpServerRegistry(self.mock_client)
        
    @pytest.mark.asyncio
    async def test_register_server_validation_error(self):
        """Test validation error in register_server (line 90)."""
        # This will trigger URL validation
        with pytest.raises(ValidationError):
            await self.mcp_registry.register_server(
                server_id="test",
                name="Test Server",
                endpoint="invalid-url",
                owner=self.owner
            )
            
    @pytest.mark.asyncio
    async def test_register_server_already_exists(self):
        """Test server already exists error (lines 108-111)."""
        # Mock existing server
        mock_server = McpServerRegistryEntry(
            server_id="existing",
            name="Existing Server",
            endpoint_url="https://existing.com",
            owner=self.owner.pubkey(),
            status=McpServerStatus.ACTIVE
        )
        
        self.mock_client.get_account_info.return_value = Mock(value=Mock(data=b"mock_data"))
        
        with patch.object(self.mcp_registry, '_deserialize_server_data', return_value=mock_server):
            with pytest.raises(RegistrationError, match="already exists"):
                await self.mcp_registry.register_server(
                    server_id="existing",
                    name="Test Server",
                    endpoint="https://test.com",
                    owner=self.owner
                )
                
    @pytest.mark.asyncio
    async def test_update_server_not_found(self):
        """Test server not found error in update_server (lines 148, 150)."""
        self.mock_client.get_account_info.return_value = Mock(value=None)
        
        with pytest.raises(RegistrationError, match="MCP server not found"):
            await self.mcp_registry.update_server(
                server_id="nonexistent",
                owner=self.owner,
                name="New Name"
            )
            
    @pytest.mark.asyncio
    async def test_update_server_transaction_error(self):
        """Test transaction failure in update_server (lines 167-170)."""
        # Mock existing server
        mock_server = McpServerRegistryEntry(
            server_id="test",
            name="Test Server",
            endpoint_url="https://test.com",
            owner=self.owner.pubkey(),
            status=McpServerStatus.ACTIVE
        )
        self.mock_client.get_account_info.return_value = Mock(value=Mock(data=b"mock_data"))
        self.mock_client.send_transaction.side_effect = Exception("Update failed")
        
        with patch.object(self.mcp_registry, '_deserialize_server_data', return_value=mock_server):
            with pytest.raises(SolanaAIRegistriesError, match="Failed to update MCP server"):
                await self.mcp_registry.update_server(
                    server_id="test",
                    owner=self.owner,
                    name="New Name"
                )
                
    @pytest.mark.asyncio
    async def test_ping_server_timeout(self):
        """Test ping server timeout (lines 198, 204-214)."""
        with patch('asyncio.wait_for', side_effect=asyncio.TimeoutError()):
            status = await self.mcp_registry.ping_server("https://timeout.com")
            assert status == "unreachable"
            
    @pytest.mark.asyncio
    async def test_ping_server_error_response(self):
        """Test ping server error response (lines 267-272)."""
        mock_response = Mock()
        mock_response.status_code = 500
        mock_response.json.return_value = {"error": "Server error"}
        
        with patch('httpx.AsyncClient') as mock_httpx:
            mock_client = AsyncMock()
            mock_httpx.return_value.__aenter__.return_value = mock_client
            mock_client.get.return_value = mock_response
            
            status = await self.mcp_registry.ping_server("https://error.com")
            assert status == "error"
            
    @pytest.mark.asyncio
    async def test_list_servers_rpc_error(self):
        """Test RPC error in list_servers_by_owner (lines 301-303)."""
        self.mock_client.get_multiple_accounts.side_effect = Exception("RPC failed")
        
        with pytest.raises(Exception):
            await self.mcp_registry.list_servers_by_owner(self.owner.pubkey())
            
    @pytest.mark.asyncio
    async def test_search_servers_rpc_error(self):
        """Test RPC error in search_servers (lines 335-337)."""
        self.mock_client.get_multiple_accounts.side_effect = Exception("Search failed")
        
        with pytest.raises(Exception):
            await self.mcp_registry.search_servers(name="test")
            
    @pytest.mark.asyncio
    async def test_deserialize_server_data_error(self):
        """Test _deserialize_server_data error (lines 388-390)."""
        with pytest.raises(Exception):
            self.mcp_registry._deserialize_server_data(b"invalid_data")


class TestComprehensivePaymentsCoverage:
    """Comprehensive tests for payments.py to reach 95% coverage."""
    
    def setup_method(self):
        """Setup test fixtures."""
        self.mock_client = Mock(spec=SolanaAIRegistriesClient)
        self.mock_client.client = AsyncMock()
        self.mock_client.send_transaction = AsyncMock(return_value="mock_signature")
        self.mock_client.get_account_info = AsyncMock()
        self.mock_client.build_transfer_instruction = Mock()
        
        self.payment_manager = PaymentManager(self.mock_client)
        
    @pytest.mark.asyncio
    async def test_create_prepay_escrow_insufficient_funds(self):
        """Test insufficient funds error in create_prepay_escrow (line 199)."""
        # Mock insufficient balance
        self.mock_client.get_account_info.return_value = Mock(value=Mock(lamports=1))
        
        with pytest.raises(InsufficientFundsError):
            await self.payment_manager.create_prepay_escrow(
                service_provider=Pubkey("11111111111111111111111111111112"),
                amount=Decimal("10.0"),
                payer=Keypair()
            )
            
    @pytest.mark.asyncio
    async def test_pay_per_usage_insufficient_funds_reraise(self):
        """Test InsufficientFundsError re-raising in pay_per_usage (lines 198-199)."""
        # Mock validate_balance to raise InsufficientFundsError
        with patch.object(self.payment_manager, '_validate_balance', side_effect=InsufficientFundsError(100, 50, "mint")):
            with pytest.raises(InsufficientFundsError):
                await self.payment_manager.pay_per_usage(
                    service_provider=Pubkey("11111111111111111111111111111112"),
                    amount=Decimal("1.0"),
                    payer=Keypair()
                )
                
    @pytest.mark.asyncio
    async def test_pay_per_usage_general_error(self):
        """Test general error handling in pay_per_usage (lines 200-201)."""
        # Mock transaction failure
        self.mock_client.send_transaction.side_effect = Exception("Payment failed")
        
        with pytest.raises(PaymentError, match="Failed to process pay-per-usage"):
            await self.payment_manager.pay_per_usage(
                service_provider=Pubkey("11111111111111111111111111111112"),
                amount=Decimal("1.0"),
                payer=Keypair()
            )
            
    @pytest.mark.asyncio
    async def test_create_payment_stream_invalid_rate(self):
        """Test invalid rate in create_payment_stream (lines 228-264)."""
        # Test zero rate
        with pytest.raises(ValueError, match="Rate must be positive"):
            stream = self.payment_manager.create_payment_stream(
                service_provider=Pubkey("11111111111111111111111111111112"),
                rate_per_second=Decimal("0"),
                payer=Keypair(),
                duration_seconds=10
            )
            async for _ in stream:
                break
                
        # Test negative rate
        with pytest.raises(ValueError, match="Rate must be positive"):
            stream = self.payment_manager.create_payment_stream(
                service_provider=Pubkey("11111111111111111111111111111112"),
                rate_per_second=Decimal("-1"),
                payer=Keypair(),
                duration_seconds=10
            )
            async for _ in stream:
                break
                
    @pytest.mark.asyncio
    async def test_create_payment_stream_duration_exhausted(self):
        """Test payment stream duration exhaustion (lines 276-307)."""
        # Setup mock for successful transaction
        self.mock_client.send_transaction = AsyncMock(return_value="stream_signature")
        
        # Create stream with very short duration
        stream = self.payment_manager.create_payment_stream(
            service_provider=Pubkey("11111111111111111111111111111112"),
            rate_per_second=Decimal("1.0"),
            payer=Keypair(),
            duration_seconds=1,  # Very short duration
            start_immediately=True
        )
        
        # Collect all signatures before duration expires
        signatures = []
        try:
            async for signature in stream:
                signatures.append(signature)
                if len(signatures) >= 2:  # Collect a few then break
                    break
                await asyncio.sleep(0.1)  # Small delay
        except StopAsyncIteration:
            pass
            
        assert len(signatures) >= 1
        
    @pytest.mark.asyncio
    async def test_get_escrow_balance_error_handling(self):
        """Test error handling in get_escrow_balance (lines 381-410)."""
        # Mock account not found
        self.mock_client.get_account_info.return_value = Mock(value=None)
        
        result = await self.payment_manager.get_escrow_balance(
            escrow_account=Pubkey("11111111111111111111111111111112")
        )
        assert result == Decimal("0.0")
        
        # Mock account info error
        self.mock_client.get_account_info.side_effect = Exception("RPC error")
        
        with pytest.raises(PaymentError, match="Failed to get escrow balance"):
            await self.payment_manager.get_escrow_balance(
                escrow_account=Pubkey("11111111111111111111111111111112")
            )
            
    @pytest.mark.asyncio
    async def test_get_payment_history_error(self):
        """Test error handling in get_payment_history (lines 414-415)."""
        self.mock_client.get_multiple_accounts.side_effect = Exception("History error")
        
        with pytest.raises(PaymentError, match="Failed to get payment history"):
            await self.payment_manager.get_payment_history(
                payer=Pubkey("11111111111111111111111111111112")
            )
            
    @pytest.mark.asyncio
    async def test_validate_balance_error_cases(self):
        """Test error cases in _validate_balance (lines 446-448)."""
        # Mock account not found
        self.mock_client.get_account_info.return_value = Mock(value=None)
        
        with pytest.raises(InsufficientFundsError):
            await self.payment_manager._validate_balance(
                payer=Pubkey("11111111111111111111111111111112"),
                required_amount=Decimal("1.0"),
                token_mint=Pubkey("11111111111111111111111111111112")
            )
            
    @pytest.mark.asyncio
    async def test_validate_payment_amount_errors(self):
        """Test _validate_payment_amount error cases (line 462)."""
        with pytest.raises(PaymentError, match="Amount must be positive"):
            await self.payment_manager._validate_payment_amount(Decimal("0"))
            
        with pytest.raises(PaymentError, match="Amount must be positive"):
            await self.payment_manager._validate_payment_amount(Decimal("-5"))
            
    @pytest.mark.asyncio
    async def test_stop_payment_stream_not_found(self):
        """Test stop_payment_stream with non-existent stream (lines 566-573)."""
        # Try to stop a stream that doesn't exist
        result = await self.payment_manager.stop_payment_stream("nonexistent_stream")
        assert result is False
        
    @pytest.mark.asyncio
    async def test_close_with_active_streams(self):
        """Test close method with active streams (lines 625-626, 632, 636)."""
        # Mock active streams
        self.payment_manager._active_streams = {
            "stream1": AsyncMock(),
            "stream2": AsyncMock()
        }
        
        await self.payment_manager.close()
        
        # Verify all streams were cancelled
        for stream_id, task in self.payment_manager._active_streams.items():
            task.cancel.assert_called_once()


class TestComprehensiveIDLCoverage:
    """Comprehensive tests for idl.py to reach 95% coverage."""
    
    def setup_method(self):
        """Setup test fixtures."""
        self.idl_loader = IDLLoader()
        
    @pytest.mark.asyncio
    async def test_load_idl_from_file_not_found(self):
        """Test file not found error in load_idl_from_file (lines 107-108)."""
        with pytest.raises(FileNotFoundError):
            await self.idl_loader.load_idl_from_file("nonexistent_file.json")
            
    @pytest.mark.asyncio
    async def test_load_idl_from_file_json_error(self):
        """Test JSON decode error in load_idl_from_file (lines 116-120)."""
        # Mock file exists but has invalid JSON
        mock_open = MagicMock()
        mock_file = MagicMock()
        mock_file.read.return_value = "invalid json {"
        mock_open.return_value.__enter__.return_value = mock_file
        
        with patch('builtins.open', mock_open):
            with pytest.raises(Exception):  # JSON decode error
                await self.idl_loader.load_idl_from_file("invalid.json")
                
    @pytest.mark.asyncio
    async def test_load_idl_from_url_error(self):
        """Test URL loading error in load_idl_from_url (lines 137-142)."""
        with patch('httpx.AsyncClient') as mock_httpx:
            mock_client = AsyncMock()
            mock_httpx.return_value.__aenter__.return_value = mock_client
            mock_client.get.side_effect = Exception("Network error")
            
            with pytest.raises(Exception):
                await self.idl_loader.load_idl_from_url("https://invalid.com/idl.json")
                
    def test_generate_python_type_unsupported_type(self):
        """Test unsupported type error in _generate_python_type (lines 345-354)."""
        unsupported_type_def = {
            "name": "UnsupportedType",
            "type": {
                "kind": "struct",
                "fields": [
                    {"name": "field", "type": {"unsupported_type": "unknown"}}
                ]
            }
        }
        
        with pytest.raises(ValueError, match="Unsupported type"):
            self.idl_loader._generate_python_type(unsupported_type_def)
            
    def test_parse_type_unsupported_complex_type(self):
        """Test unsupported complex type in _parse_type (lines 372-377)."""
        with pytest.raises(ValueError, match="Unsupported type"):
            self.idl_loader._parse_type({"unknown_complex_type": {"inner": "type"}})
            
    def test_parse_type_unsupported_primitive(self):
        """Test unsupported primitive type in _parse_type (lines 395-400)."""
        with pytest.raises(ValueError, match="Unsupported type"):
            self.idl_loader._parse_type("unknown_primitive_type")


class TestComprehensiveClientCoverage:
    """Comprehensive tests for client.py to reach 95% coverage."""
    
    def setup_method(self):
        """Setup test fixtures."""
        self.client = SolanaAIRegistriesClient("https://api.devnet.solana.com")
        
    @pytest.mark.asyncio
    async def test_retry_rpc_call_max_retries_exceeded(self):
        """Test max retries exceeded in _retry_rpc_call (lines 111, 146-147)."""
        # Mock function that always fails
        mock_func = AsyncMock(side_effect=Exception("Always fails"))
        
        with pytest.raises(Exception, match="Always fails"):
            await self.client._retry_rpc_call(mock_func, max_retries=2)
            
    @pytest.mark.asyncio
    async def test_get_account_info_with_commitment(self):
        """Test get_account_info with commitment parameter (lines 176, 181-182)."""
        self.client.client = AsyncMock()
        mock_response = Mock(value=Mock(data=b"test_data"))
        self.client.client.get_account_info.return_value = mock_response
        
        result = await self.client.get_account_info(
            Pubkey("11111111111111111111111111111112"),
            commitment="finalized"
        )
        
        assert result == mock_response
        
    @pytest.mark.asyncio
    async def test_send_transaction_with_custom_options(self):
        """Test send_transaction with custom options (lines 258-280)."""
        self.client.client = AsyncMock()
        self.client.client.get_latest_blockhash.return_value = Mock(
            value=Mock(blockhash="mock_blockhash")
        )
        self.client.client.send_transaction.return_value = Mock(
            value="mock_signature"
        )
        
        # Create a simple mock transaction
        mock_transaction = Mock()
        mock_transaction.recent_blockhash = "mock_blockhash"
        
        signers = [Keypair()]
        
        result = await self.client.send_transaction(
            mock_transaction,
            signers,
            commitment="confirmed",
            skip_preflight=True,
            max_retries=5
        )
        
        assert result == "mock_signature"
        
    @pytest.mark.asyncio
    async def test_get_multiple_accounts_error_handling(self):
        """Test error handling in get_multiple_accounts (lines 392-403)."""
        self.client.client = AsyncMock()
        self.client.client.get_multiple_accounts.side_effect = Exception("RPC error")
        
        with pytest.raises(Exception):
            await self.client.get_multiple_accounts([
                Pubkey("11111111111111111111111111111112")
            ])
            
    @pytest.mark.asyncio
    async def test_build_instruction_methods_error_handling(self):
        """Test error handling in build instruction methods (lines 437-442, 504-515)."""
        # Test register agent instruction error
        with pytest.raises(Exception):
            self.client.build_register_agent_instruction(
                agent_id="test",
                name="Test Agent",
                description="Test",
                owner=Pubkey("11111111111111111111111111111112"),
                invalid_param="should_fail"  # This should cause an error
            )
            
    def test_derive_pda_methods(self):
        """Test PDA derivation methods (lines 550, 570, 578, 585-587)."""
        agent_pda = self.client.derive_agent_pda(
            "test_agent",
            Pubkey("11111111111111111111111111111112")
        )
        assert isinstance(agent_pda, Pubkey)
        
        mcp_pda = self.client.derive_mcp_server_pda(
            "test_server", 
            Pubkey("11111111111111111111111111111112")
        )
        assert isinstance(mcp_pda, Pubkey)
        
        escrow_pda = self.client.derive_escrow_pda(
            Pubkey("11111111111111111111111111111112"),
            Pubkey("11111111111111111111111111111113")
        )
        assert isinstance(escrow_pda, Pubkey)
        
    @pytest.mark.asyncio
    async def test_context_manager_error_handling(self):
        """Test context manager error handling (lines 623, 709-712)."""
        # Test normal context manager usage
        async with self.client:
            assert self.client.client is not None
            
        # Test that client is properly closed
        # Note: We can't easily test the actual close() call without mocking
        # but we can test that the context manager works
        pass


class TestSpecificLineCoverageTargets:
    """Tests targeting specific uncovered lines for 95% coverage."""
    
    @pytest.mark.asyncio
    async def test_payment_manager_private_methods(self):
        """Test private methods in PaymentManager for full coverage."""
        mock_client = Mock()
        pm = PaymentManager(mock_client)
        
        # Test _get_associated_token_account
        result = await pm._get_associated_token_account(
            Pubkey("11111111111111111111111111111112"),
            Pubkey("11111111111111111111111111111113")
        )
        assert isinstance(result, Pubkey)
        
        # Test _derive_escrow_pda  
        result = pm._derive_escrow_pda(
            Pubkey("11111111111111111111111111111112"),
            Pubkey("11111111111111111111111111111113")
        )
        assert isinstance(result, Pubkey)
        
    def test_type_validation_comprehensive(self):
        """Test comprehensive type validation for all edge cases."""
        from solana_ai_registries.types import (
            ServiceEndpoint, AgentSkill, MCPTool, MCPResource, MCPPrompt
        )
        
        # Test ServiceEndpoint with all protocol types
        for protocol in ["https", "http"]:
            endpoint = ServiceEndpoint(url=f"{protocol}://test.com")
            assert endpoint.protocol == protocol
            
        # Test validation errors for endpoints
        with pytest.raises(ValueError):
            ServiceEndpoint(url="ftp://invalid.com")
            
        # Test skill validation with edge cases
        skill = AgentSkill(
            skill_id="test",
            name="Test Skill",
            description="A" * 512,  # Max length
            category="test_category",
            tags=["tag1", "tag2", "tag3", "tag4", "tag5"]  # Max tags
        )
        assert len(skill.tags) == 5
        
        # Test MCP component validation
        tool = McpTool(
            name="test_tool",
            description="Test tool",
            tags=["tag1", "tag2", "tag3"]  # Max tags
        )
        assert len(tool.tags) == 3
        
        resource = McpResource(
            uri_pattern="test/*",
            name="Test Resource",
            description="Test resource",
            tags=["tag1", "tag2", "tag3"]  # Max tags
        )
        assert len(resource.tags) == 3
        
        prompt = McpPrompt(
            name="test_prompt",
            description="Test prompt",
            tags=["tag1", "tag2", "tag3"]  # Max tags
        )
        assert len(prompt.tags) == 3
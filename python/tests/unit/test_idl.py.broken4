"""Simplified tests for solana_ai_registries.idl module focused on interface coverage."""

import pytest
from unittest.mock import Mock, patch, mock_open
from typing import Dict, Any, Type
import json

from solana_ai_registries.idl import IDLLoader, ParsedIdl, IdlAccount, IdlInstruction, IdlType, IdlError
from solana_ai_registries.exceptions import IdlLoadError


class TestIDLLoaderInterface:
    """Test IDLLoader interface and basic functionality."""

    def setup_method(self):
        """Set up test fixtures."""
        self.idl_loader = IDLLoader()

    def test_init(self):
        """Test IDLLoader initialization."""
        loader = IDLLoader()
        assert loader._cached_idls == {}
        assert loader._generated_types == {}

    def test_has_required_methods(self):
        """Test that IDLLoader has expected methods."""
        expected_methods = [
            'load_idl',
            'generate_types',
            'get_instruction_discriminant',
            'get_account_layout',
            'clear_cache'
        ]
        for method in expected_methods:
            assert hasattr(self.idl_loader, method)
            assert callable(getattr(self.idl_loader, method))

    def test_load_idl_nonexistent_program(self):
        """Test loading IDL for nonexistent program."""
        with pytest.raises(Exception):  # Could be IdlLoadError or other exception
            self.idl_loader.load_idl("nonexistent_program")

    @patch('solana_ai_registries.idl.IDLLoader._load_from_resources')
    def test_load_idl_from_resources_success(self, mock_load):
        """Test successful IDL loading from resources."""
        sample_idl_data = {
            "version": "1.0.0",
            "name": "test_program",
            "instructions": [],
            "accounts": [],
            "types": []
        }
        mock_load.return_value = sample_idl_data
        
        result = self.idl_loader.load_idl("test_program")
        assert isinstance(result, ParsedIdl)
        assert result.name == "test_program"
        assert result.version == "1.0.0"

    @patch('solana_ai_registries.idl.IDLLoader._load_from_file')
    @patch('solana_ai_registries.idl.IDLLoader._load_from_resources')
    def test_load_idl_fallback_to_file(self, mock_resources, mock_file):
        """Test IDL loading fallback to file."""
        sample_idl_data = {
            "version": "1.0.0",
            "name": "test_program",
            "instructions": [],
            "accounts": [],
            "types": []
        }
        mock_resources.side_effect = FileNotFoundError()
        mock_file.return_value = sample_idl_data
        
        result = self.idl_loader.load_idl("test_program")
        assert isinstance(result, ParsedIdl)

    def test_load_from_resources_interface(self):
        """Test _load_from_resources interface."""
        # This should raise FileNotFoundError for non-existent resources
        with pytest.raises(FileNotFoundError):
            self.idl_loader._load_from_resources("nonexistent")

    def test_load_from_file_not_found(self):
        """Test file loading when file doesn't exist."""
        with pytest.raises(FileNotFoundError):
            self.idl_loader._load_from_file("nonexistent")

    def test_parse_idl_interface(self):
        """Test IDL parsing interface."""
        sample_idl_data = {
            "version": "1.0.0",
            "name": "test_program",
            "instructions": [],
            "accounts": [],
            "types": []
        }
        parsed = self.idl_loader._parse_idl(sample_idl_data)
        assert isinstance(parsed, ParsedIdl)
        assert parsed.name == "test_program"
        assert parsed.version == "1.0.0"

    def test_generate_types_interface(self):
        """Test type generation interface."""
        parsed_idl = ParsedIdl(
            name="test",
            version="1.0.0",
            instructions=[],
            accounts=[],
            types=[]
        )
        types = self.idl_loader.generate_types(parsed_idl)
        
        assert isinstance(types, dict)

    def test_generate_account_class_interface(self):
        """Test account class generation."""
        account = IdlAccount(
            name="TestAccount",
            type={
                "kind": "struct",
                "fields": [
                    {"name": "balance", "type": "u64"},
                    {"name": "owner", "type": "publicKey"}
                ]
            }
        )
        
        result = self.idl_loader._generate_account_class(account)
        assert isinstance(result, type)

    def test_generate_instruction_class_interface(self):
        """Test instruction class generation."""
        instruction = IdlInstruction(
            name="test_instruction",
            accounts=[
                {"name": "user", "isMut": True, "isSigner": True}
            ],
            args=[
                {"name": "amount", "type": "u64"}
            ]
        )
        
        result = self.idl_loader._generate_instruction_class(instruction)
        assert isinstance(result, type)

    def test_map_idl_type_to_python_basic_types(self):
        """Test IDL type mapping for basic types."""
        # Test string types
        assert self.idl_loader._map_idl_type_to_python("u64") == int
        assert self.idl_loader._map_idl_type_to_python("string") == str
        assert self.idl_loader._map_idl_type_to_python("bool") == bool

    def test_map_idl_type_to_python_unknown_type(self):
        """Test IDL type mapping for unknown types."""
        # Should return Any for unknown types
        result = self.idl_loader._map_idl_type_to_python("unknown_type")
        # Should not raise an exception
        assert result is not None

    def test_get_instruction_discriminant_interface(self):
        """Test instruction discriminant calculation."""
        # Mock load_idl to return test data
        with patch.object(self.idl_loader, 'load_idl') as mock_load:
            mock_idl = ParsedIdl(
                name="test",
                version="1.0.0",
                instructions=[
                    IdlInstruction(
                        name="initialize",
                        accounts=[],
                        args=[]
                    )
                ],
                accounts=[],
                types=[]
            )
            mock_load.return_value = mock_idl
            
            result = self.idl_loader.get_instruction_discriminant("test_program", "initialize")
            # Should return None or a discriminant value
            assert result is None or isinstance(result, int)

    def test_get_account_layout_interface(self):
        """Test account layout generation."""
        # Mock load_idl to return test data
        with patch.object(self.idl_loader, 'load_idl') as mock_load:
            mock_idl = ParsedIdl(
                name="test",
                version="1.0.0",
                instructions=[],
                accounts=[
                    IdlAccount(
                        name="TestAccount",
                        type={
                            "kind": "struct",
                            "fields": [
                                {"name": "balance", "type": "u64"}
                            ]
                        }
                    )
                ],
                types=[]
            )
            mock_load.return_value = mock_idl
            
            result = self.idl_loader.get_account_layout("test_program", "TestAccount")
            # Should return None or a layout dict
            assert result is None or isinstance(result, dict)

    def test_clear_cache_interface(self):
        """Test cache clearing."""
        # Add something to cache first
        self.idl_loader._cached_idls["test"] = ParsedIdl(
            name="test", version="1.0.0", instructions=[], accounts=[], types=[]
        )
        assert len(self.idl_loader._cached_idls) > 0
        
        # Clear cache
        self.idl_loader.clear_cache()
        assert len(self.idl_loader._cached_idls) == 0

    def test_caching_behavior(self):
        """Test that IDL loading uses caching."""
        with patch.object(self.idl_loader, '_load_from_resources') as mock_load:
            sample_idl_data = {
                "version": "1.0.0",
                "name": "test_program",
                "instructions": [],
                "accounts": [],
                "types": []
            }
            mock_load.return_value = sample_idl_data
            
            # First load
            result1 = self.idl_loader.load_idl("test_program")
            # Second load should use cache
            result2 = self.idl_loader.load_idl("test_program")
            
            # Should only call _load_from_resources once due to caching
            assert mock_load.call_count == 1
            assert result1.name == result2.name

    def test_generate_type_class_interface(self):
        """Test custom type class generation."""
        custom_type = IdlType(
            name="CustomType",
            type={
                "kind": "struct",
                "fields": [
                    {"name": "value", "type": "u32"},
                    {"name": "label", "type": "string"}
                ]
            }
        )
        
        result = self.idl_loader._generate_type_class(custom_type)
        assert isinstance(result, type)
        assert result.__name__ == "CustomType"

    def test_idl_classes_interface(self):
        """Test that IDL data classes work properly."""
        # Test IdlInstruction
        instruction = IdlInstruction(
            name="test_instruction",
            accounts=[{"name": "user", "isMut": True, "isSigner": True}],
            args=[{"name": "amount", "type": "u64"}]
        )
        assert instruction.name == "test_instruction"
        assert len(instruction.accounts) == 1
        assert len(instruction.args) == 1

        # Test IdlAccount
        account = IdlAccount(
            name="TestAccount",
            type={
                "kind": "struct",
                "fields": [{"name": "balance", "type": "u64"}]
            }
        )
        assert account.name == "TestAccount"
        assert account.type["kind"] == "struct"

        # Test IdlType
        idl_type = IdlType(
            name="CustomType",
            type={
                "kind": "struct",
                "fields": [{"name": "value", "type": "u32"}]
            }
        )
        assert idl_type.name == "CustomType"
        assert idl_type.type["kind"] == "struct"
"""Comprehensive tests for solana_ai_registries.agent module."""

import pytest
from unittest.mock import AsyncMock, Mock, patch
from typing import List, Optional, Dict, Any

from solders.keypair import Keypair
from solders.pubkey import Pubkey
from solders.transaction import Transaction

from solana_ai_registries.agent import AgentRegistry
from solana_ai_registries.client import SolanaAIRegistriesClient
from solana_ai_registries.exceptions import (
    InvalidInputError,
    AgentNotFoundError,
    RegistrationError,
    SolanaAIRegistriesError,
)
from solana_ai_registries.types import (
    AgentRegistryEntry, 
    AgentStatus, 
    ServiceEndpoint,
    AgentSkill
)


class TestAgentRegistry:
    """Comprehensive test coverage for AgentRegistry class."""

    def setup_method(self):
        """Set up test fixtures."""
        self.mock_client = Mock(spec=SolanaAIRegistriesClient)
        self.agent_registry = AgentRegistry(self.mock_client)
        
        # Create real keypair and public key
        self.owner_keypair = Keypair()
        self.other_pubkey = Keypair().pubkey()
        
        # Mock client methods
        self.mock_client.get_account_info = AsyncMock()
        self.mock_client.build_and_send_transaction = AsyncMock()
        self.mock_client.get_program_accounts = AsyncMock()
        self.mock_client.send_transaction = AsyncMock()
        
        # Mock instruction building methods 
        self.mock_client.build_register_agent_instruction = Mock()
        self.mock_client.build_update_agent_instruction = Mock()
        self.mock_client.build_deregister_agent_instruction = Mock()
        
        # Create a proper mock transaction
        self.mock_transaction = Mock(spec=Transaction)
        self.mock_transaction.sign = Mock()
        self.mock_transaction.serialize = Mock(return_value=b"mock_serialized_tx")
        
        # Sample agent data
        self.sample_agent_data = {
            "agent_id": "test_agent",
            "name": "Test AI Agent",
            "description": "A test AI agent",
            "owner": self.owner_keypair.pubkey(),
            "status": AgentStatus.ACTIVE,
            "created_at": 1640995200,
            "updated_at": 1640995200,
        }

    def test_init(self):
        """Test AgentRegistry initialization."""
        registry = AgentRegistry(self.mock_client)
        assert registry.client == self.mock_client

    def test_agent_registry_has_required_methods(self):
        """Test that AgentRegistry has the expected methods."""
        assert hasattr(self.agent_registry, 'register_agent')
        assert hasattr(self.agent_registry, 'update_agent')
        assert hasattr(self.agent_registry, 'update_agent_status')
        assert hasattr(self.agent_registry, 'get_agent')
        assert hasattr(self.agent_registry, 'deregister_agent')
        assert hasattr(self.agent_registry, 'list_agents_by_owner')
        assert hasattr(self.agent_registry, 'search_agents')

    # Registration Tests
    @pytest.mark.asyncio
    @patch('solana_ai_registries.agent.Transaction')
    async def test_register_agent_success(self, mock_transaction):
        """Test successful agent registration."""
        # Setup mocks - mock instruction building at the client level
        mock_instruction = Mock()
        self.mock_client.build_register_agent_instruction.return_value = mock_instruction
        
        # Mock transaction creation
        mock_transaction_instance = Mock()
        mock_transaction.new_with_payer.return_value = mock_transaction_instance
        
        # Mock successful registration (account doesn't exist)
        self.mock_client.get_account_info.return_value = None
        self.mock_client.send_transaction.return_value = "mock_tx_signature"
        
        # Mock get_agent to return None (agent doesn't exist)
        with patch.object(self.agent_registry, 'get_agent', return_value=None):
            result = await self.agent_registry.register_agent(
                agent_id="test_agent",
                name="Test AI Agent",
                description="A test AI agent",
                owner=self.owner_keypair
            )
        
        assert result == "mock_tx_signature"
        # Verify instruction was built correctly
        self.mock_client.build_register_agent_instruction.assert_called_once()

    @pytest.mark.asyncio
    @patch('solana_ai_registries.agent.Transaction')
    async def test_register_agent_with_service_endpoint(self, mock_transaction):
        """Test agent registration with service endpoint."""
        # Setup mocks
        mock_instruction = Mock()
        self.mock_client.build_register_agent_instruction.return_value = mock_instruction
        
        # Mock transaction creation
        mock_transaction_instance = Mock()
        mock_transaction.new_with_payer.return_value = mock_transaction_instance
        
        service_endpoint = ServiceEndpoint(
            url="https://api.example.com/agent",
            auth_type="bearer_token",
            auth_config={"token": "secret_token"}
        )
        
        self.mock_client.get_account_info.return_value = None
        self.mock_client.send_transaction.return_value = "mock_tx_signature"
        
        result = await self.agent_registry.register_agent(
            agent_id="test_agent",
            name="Test AI Agent",
            description="A test AI agent",
            owner=self.owner_keypair,
            service_endpoint=service_endpoint
        )
        
        assert result == "mock_tx_signature"

    @pytest.mark.asyncio
    async def test_register_agent_with_skills(self):
        """Test agent registration with skills."""
        # Setup mocks
        mock_instruction = Mock()
        self.mock_client.build_register_agent_instruction.return_value = mock_instruction
        
        skills = [
            AgentSkill(
                skill_id="skill_1",
                name="text_generation",
                description="Generate human-like text",
                category="nlp"
            ),
            AgentSkill(
                skill_id="skill_2", 
                name="sentiment_analysis",
                description="Analyze sentiment in text",
                category="nlp"
            )
        ]
        
        self.mock_client.get_account_info.return_value = None
        self.mock_client.send_transaction.return_value = "mock_tx_signature"
        
        result = await self.agent_registry.register_agent(
            agent_id="test_agent",
            name="Test AI Agent",
            description="A test AI agent",
            owner=self.owner_keypair,
            skills=skills,
            metadata_uri="https://example.com/agent_metadata.json"
        )
        
        assert result == "mock_tx_signature"

    @pytest.mark.asyncio
    async def test_register_agent_invalid_agent_id(self):
        """Test agent registration with invalid agent ID."""
        # Test empty agent ID
        with pytest.raises(InvalidInputError, match="agent_id cannot be empty"):
            await self.agent_registry.register_agent(
                agent_id="",
                name="Test Agent",
                description="Test description",
                owner=self.owner_keypair
            )
        
        # Test agent ID too long
        long_agent_id = "x" * 65  # Exceeds MAX_AGENT_ID_LEN (64)
        with pytest.raises(InvalidInputError, match="agent_id exceeds maximum length"):
            await self.agent_registry.register_agent(
                agent_id=long_agent_id,
                name="Test Agent",
                description="Test description",
                owner=self.owner_keypair
            )

    @pytest.mark.asyncio
    async def test_register_agent_invalid_name(self):
        """Test agent registration with invalid name."""
        with pytest.raises(InvalidInputError, match="name cannot be empty"):
            await self.agent_registry.register_agent(
                agent_id="test_agent",
                name="",
                description="Test description",
                owner=self.owner_keypair
            )

    @pytest.mark.asyncio
    async def test_register_agent_invalid_description(self):
        """Test agent registration with invalid description."""
        with pytest.raises(InvalidInputError, match="description cannot be empty"):
            await self.agent_registry.register_agent(
                agent_id="test_agent",
                name="Test Agent",
                description="",
                owner=self.owner_keypair
            )

    @pytest.mark.asyncio
    async def test_register_agent_already_exists(self):
        """Test agent registration when agent already exists."""
        # Mock account exists (agent already registered)
        mock_account_info = Mock()
        mock_account_info.value = Mock()
        mock_account_info.value.data = b'\x00' * 100  # Mock account data
        self.mock_client.get_account_info.return_value = mock_account_info
        
        with pytest.raises(RegistrationError, match="already exists"):
            await self.agent_registry.register_agent(
                agent_id="existing_agent",
                name="Test Agent",
                description="Test description",
                owner=self.owner_keypair
            )

    @pytest.mark.asyncio
    async def test_register_agent_transaction_failure(self):
        """Test agent registration when transaction fails."""
        # Setup mocks
        mock_instruction = Mock()
        self.mock_client.build_register_agent_instruction.return_value = mock_instruction
        
        # Mock account doesn't exist (new registration)
        self.mock_client.get_account_info.return_value = None
        # Mock transaction failure
        self.mock_client.send_transaction.side_effect = Exception("Transaction failed")
        
        with pytest.raises(RegistrationError, match="Failed to register agent"):
            await self.agent_registry.register_agent(
                agent_id="test_agent",
                name="Test Agent",
                description="Test description",
                owner=self.owner_keypair
            )

    # Update Tests
    @pytest.mark.asyncio
    async def test_update_agent_success(self):
        """Test successful agent update."""
        # Mock agent exists
        mock_agent = AgentRegistryEntry(**self.sample_agent_data)
        
        with patch.object(self.agent_registry, 'get_agent', return_value=mock_agent):
            self.mock_client.build_and_send_transaction.return_value = "mock_tx_signature"
            
            updates = {
                "name": "Updated Agent Name",
                "description": "Updated description"
            }
            
            result = await self.agent_registry.update_agent(
                agent_id="test_agent",
                owner=self.owner_keypair,
                updates=updates
            )
            
            assert result == "mock_tx_signature"

    @pytest.mark.asyncio
    async def test_update_agent_not_found(self):
        """Test agent update when agent not found."""
        with patch.object(self.agent_registry, 'get_agent', return_value=None):
            updates = {"name": "Updated Name"}
            
            with pytest.raises(AgentNotFoundError):
                await self.agent_registry.update_agent(
                    agent_id="nonexistent_agent",
                    owner=self.owner_keypair,
                    updates=updates
                )

    @pytest.mark.asyncio
    async def test_update_agent_status_success(self):
        """Test successful agent status update."""
        # Mock agent exists
        mock_agent = AgentRegistryEntry(**self.sample_agent_data)
        
        with patch.object(self.agent_registry, 'get_agent', return_value=mock_agent):
            self.mock_client.build_and_send_transaction.return_value = "mock_tx_signature"
            
            result = await self.agent_registry.update_agent_status(
                agent_id="test_agent",
                owner=self.owner_keypair,
                status=AgentStatus.INACTIVE
            )
            
            assert result == "mock_tx_signature"

    @pytest.mark.asyncio
    async def test_update_agent_invalid_updates(self):
        """Test agent update with invalid updates."""
        mock_agent = AgentRegistryEntry(**self.sample_agent_data)
        
        with patch.object(self.agent_registry, 'get_agent', return_value=mock_agent):
            # Test empty updates
            with pytest.raises(InvalidInputError, match="updates cannot be empty"):
                await self.agent_registry.update_agent(
                    agent_id="test_agent",
                    owner=self.owner_keypair,
                    updates={}
                )
            
            # Test invalid field
            with pytest.raises(InvalidInputError, match="Invalid update field"):
                await self.agent_registry.update_agent(
                    agent_id="test_agent",
                    owner=self.owner_keypair,
                    updates={"invalid_field": "value"}
                )

    # Get Agent Tests
    @pytest.mark.asyncio
    async def test_get_agent_success(self):
        """Test successful agent retrieval."""
        # Mock account exists with data
        mock_account_info = Mock()
        mock_account_info.value = Mock()
        mock_account_info.value.data = b'\x00' * 200  # Mock agent account data
        self.mock_client.get_account_info.return_value = mock_account_info
        
        with patch('struct.unpack') as mock_unpack:
            # Mock unpacked data
            mock_unpack.return_value = (
                1,  # status
                b'test_agent\x00' * 10,  # agent_id (padded)
                b'Test Agent\x00' * 10,  # name (padded)
                b'Test description\x00' * 10,  # description (padded)
                1640995200,  # created_at
                1640995200,  # updated_at
            )
            
            result = await self.agent_registry.get_agent(
                agent_id="test_agent",
                owner=self.owner_keypair.pubkey()
            )
            
            assert result is not None
            assert isinstance(result, AgentRegistryEntry)

    @pytest.mark.asyncio
    async def test_get_agent_not_found(self):
        """Test agent retrieval when agent doesn't exist."""
        self.mock_client.get_account_info.return_value = None
        
        result = await self.agent_registry.get_agent(
            agent_id="nonexistent_agent",
            owner=self.owner_keypair.pubkey()
        )
        
        assert result is None

    @pytest.mark.asyncio
    async def test_get_agent_invalid_data(self):
        """Test agent retrieval with invalid account data."""
        # Mock account exists but with invalid data
        mock_account_info = Mock()
        mock_account_info.value = Mock()
        mock_account_info.value.data = b'\x00' * 10  # Too short
        self.mock_client.get_account_info.return_value = mock_account_info
        
        with pytest.raises(Exception):  # Should raise deserialization error
            await self.agent_registry.get_agent(
                agent_id="test_agent",
                owner=self.owner_keypair.pubkey()
            )

    @pytest.mark.asyncio
    async def test_get_agent_deserialization_error(self):
        """Test agent retrieval with deserialization error."""
        mock_account_info = Mock()
        mock_account_info.value = Mock()
        mock_account_info.value.data = b'\x00' * 200
        self.mock_client.get_account_info.return_value = mock_account_info
        
        with patch('struct.unpack') as mock_unpack:
            mock_unpack.side_effect = Exception("Unpacking failed")
            
            with pytest.raises(Exception, match="Unpacking failed"):
                await self.agent_registry.get_agent(
                    agent_id="test_agent",
                    owner=self.owner_keypair.pubkey()
                )

    # Deregister Tests
    @pytest.mark.asyncio
    async def test_deregister_agent_success(self):
        """Test successful agent deregistration."""
        # Mock agent exists
        mock_agent = AgentRegistryEntry(**self.sample_agent_data)
        
        with patch.object(self.agent_registry, 'get_agent', return_value=mock_agent):
            self.mock_client.build_and_send_transaction.return_value = "mock_tx_signature"
            
            result = await self.agent_registry.deregister_agent(
                agent_id="test_agent",
                owner=self.owner_keypair
            )
            
            assert result == "mock_tx_signature"

    @pytest.mark.asyncio
    async def test_deregister_agent_not_found(self):
        """Test agent deregistration when agent not found."""
        with patch.object(self.agent_registry, 'get_agent', return_value=None):
            with pytest.raises(AgentNotFoundError):
                await self.agent_registry.deregister_agent(
                    agent_id="nonexistent_agent",
                    owner=self.owner_keypair
                )

    # List Agents Tests
    @pytest.mark.asyncio
    async def test_list_agents_by_owner_success(self):
        """Test successful listing of agents by owner."""
        # Mock multiple agent accounts
        mock_accounts = [
            Mock(
                pubkey=Keypair().pubkey(),
                account=Mock(data=b'\x00' * 200)
            ),
            Mock(
                pubkey=Keypair().pubkey(),
                account=Mock(data=b'\x00' * 200)
            )
        ]
        self.mock_client.get_program_accounts.return_value = mock_accounts
        
        with patch('struct.unpack') as mock_unpack:
            mock_unpack.return_value = (
                1,  # status
                b'test_agent\x00' * 10,
                b'Test Agent\x00' * 10,
                b'Test description\x00' * 10,
                1640995200,
                1640995200,
            )
            
            result = await self.agent_registry.list_agents_by_owner(
                owner=self.owner_keypair.pubkey()
            )
            
            assert isinstance(result, list)
            assert len(result) == 2

    @pytest.mark.asyncio
    async def test_list_agents_by_owner_empty(self):
        """Test listing agents when owner has no agents."""
        self.mock_client.get_program_accounts.return_value = []
        
        result = await self.agent_registry.list_agents_by_owner(
            owner=self.owner_keypair.pubkey()
        )
        
        assert isinstance(result, list)
        assert len(result) == 0

    @pytest.mark.asyncio
    async def test_list_agents_by_owner_with_limit(self):
        """Test listing agents with limit."""
        # Mock many agent accounts
        mock_accounts = [
            Mock(pubkey=Keypair().pubkey(), account=Mock(data=b'\x00' * 200))
            for _ in range(10)
        ]
        self.mock_client.get_program_accounts.return_value = mock_accounts
        
        with patch('struct.unpack') as mock_unpack:
            mock_unpack.return_value = (
                1, b'test\x00' * 20, b'Test\x00' * 20, 
                b'Description\x00' * 20, 1640995200, 1640995200
            )
            
            result = await self.agent_registry.list_agents_by_owner(
                owner=self.owner_keypair.pubkey(),
                limit=5
            )
            
            assert isinstance(result, list)
            assert len(result) == 5

    # Search Tests
    @pytest.mark.asyncio
    async def test_search_agents_by_name(self):
        """Test searching agents by name."""
        mock_accounts = [
            Mock(pubkey=Keypair().pubkey(), account=Mock(data=b'\x00' * 200))
        ]
        self.mock_client.get_program_accounts.return_value = mock_accounts
        
        with patch('struct.unpack') as mock_unpack:
            mock_unpack.return_value = (
                1, b'matching_agent\x00' * 10, b'Matching Agent\x00' * 10,
                b'Description\x00' * 20, 1640995200, 1640995200
            )
            
            result = await self.agent_registry.search_agents(
                query="Matching"
            )
            
            assert isinstance(result, list)
            assert len(result) >= 0

    @pytest.mark.asyncio
    async def test_search_agents_by_skills(self):
        """Test searching agents by skills."""
        mock_accounts = []
        self.mock_client.get_program_accounts.return_value = mock_accounts
        
        result = await self.agent_registry.search_agents(
            skills=["text_generation", "nlp"]
        )
        
        assert isinstance(result, list)

    @pytest.mark.asyncio
    async def test_search_agents_by_status(self):
        """Test searching agents by status."""
        mock_accounts = []
        self.mock_client.get_program_accounts.return_value = mock_accounts
        
        result = await self.agent_registry.search_agents(
            status=AgentStatus.ACTIVE
        )
        
        assert isinstance(result, list)

    @pytest.mark.asyncio
    async def test_search_agents_no_results(self):
        """Test searching agents with no results."""
        self.mock_client.get_program_accounts.return_value = []
        
        result = await self.agent_registry.search_agents(
            query="nonexistent"
        )
        
        assert isinstance(result, list)
        assert len(result) == 0

    @pytest.mark.asyncio
    async def test_search_agents_with_limit(self):
        """Test searching agents with limit."""
        mock_accounts = [
            Mock(pubkey=Keypair().pubkey(), account=Mock(data=b'\x00' * 200))
            for _ in range(10)
        ]
        self.mock_client.get_program_accounts.return_value = mock_accounts
        
        with patch('struct.unpack') as mock_unpack:
            mock_unpack.return_value = (
                1, b'test\x00' * 20, b'Test\x00' * 20,
                b'Description\x00' * 20, 1640995200, 1640995200
            )
            
            result = await self.agent_registry.search_agents(
                limit=3
            )
            
            assert isinstance(result, list)
            assert len(result) == 3

    # Error Handling Tests
    @pytest.mark.asyncio
    async def test_register_agent_network_error(self):
        """Test agent registration with network error."""
        self.mock_client.get_account_info.return_value = None
        self.mock_client.build_and_send_transaction.side_effect = Exception("Network error")
        
        with pytest.raises(RegistrationError, match="Failed to register agent"):
            await self.agent_registry.register_agent(
                agent_id="test_agent",
                name="Test Agent",
                description="Test description",
                owner=self.owner_keypair
            )

    @pytest.mark.asyncio
    async def test_update_agent_network_error(self):
        """Test agent update with network error."""
        mock_agent = AgentRegistryEntry(**self.sample_agent_data)
        
        with patch.object(self.agent_registry, 'get_agent', return_value=mock_agent):
            self.mock_client.build_and_send_transaction.side_effect = Exception("Network error")
            
            with pytest.raises(Exception, match="Network error"):
                await self.agent_registry.update_agent(
                    agent_id="test_agent",
                    owner=self.owner_keypair,
                    updates={"name": "Updated Name"}
                )

    @pytest.mark.asyncio
    async def test_search_agents_rpc_error(self):
        """Test agent search with RPC error."""
        self.mock_client.get_program_accounts.side_effect = Exception("RPC error")
        
        with pytest.raises(Exception, match="RPC error"):
            await self.agent_registry.search_agents(query="test")

    # Edge Cases
    @pytest.mark.asyncio
    async def test_register_agent_minimal_data(self):
        """Test agent registration with minimal required data."""
        self.mock_client.get_account_info.return_value = None
        self.mock_client.build_and_send_transaction.return_value = "mock_tx_signature"
        
        result = await self.agent_registry.register_agent(
            agent_id="minimal_agent",
            name="Minimal Agent",
            description="Minimal description",
            owner=self.owner_keypair
        )
        
        assert result == "mock_tx_signature"

    @pytest.mark.asyncio
    async def test_update_agent_single_field(self):
        """Test updating a single agent field."""
        mock_agent = AgentRegistryEntry(**self.sample_agent_data)
        
        with patch.object(self.agent_registry, 'get_agent', return_value=mock_agent):
            self.mock_client.build_and_send_transaction.return_value = "mock_tx_signature"
            
            result = await self.agent_registry.update_agent(
                agent_id="test_agent",
                owner=self.owner_keypair,
                updates={"description": "New description only"}
            )
            
            assert result == "mock_tx_signature"

    @pytest.mark.asyncio
    async def test_list_agents_large_limit(self):
        """Test listing agents with very large limit."""
        mock_accounts = []
        self.mock_client.get_program_accounts.return_value = mock_accounts
        
        result = await self.agent_registry.list_agents_by_owner(
            owner=self.owner_keypair.pubkey(),
            limit=10000  # Very large limit
        )
        
        assert isinstance(result, list)
        assert len(result) == 0  # No agents exist

    @pytest.mark.asyncio
    async def test_search_agents_complex_query(self):
        """Test searching agents with complex query parameters."""
        mock_accounts = []
        self.mock_client.get_program_accounts.return_value = mock_accounts
        
        result = await self.agent_registry.search_agents(
            query="AI assistant",
            skills=["text_generation", "conversation"],
            status=AgentStatus.ACTIVE,
            limit=50
        )
        
        assert isinstance(result, list)
        assert len(result) == 0

    @pytest.mark.asyncio
    async def test_register_agent_max_length_fields(self):
        """Test agent registration with maximum length fields."""
        # Create strings at maximum allowed length
        max_agent_id = "a" * 64  # MAX_AGENT_ID_LEN
        max_name = "n" * 100     # Assume max name length
        max_description = "d" * 500  # Assume max description length
        
        self.mock_client.get_account_info.return_value = None
        self.mock_client.build_and_send_transaction.return_value = "mock_tx_signature"
        
        result = await self.agent_registry.register_agent(
            agent_id=max_agent_id,
            name=max_name,
            description=max_description,
            owner=self.owner_keypair
        )
        
        assert result == "mock_tx_signature"

    @pytest.mark.asyncio
    async def test_update_agent_multiple_fields(self):
        """Test updating multiple agent fields at once."""
        mock_agent = AgentRegistryEntry(**self.sample_agent_data)
        
        with patch.object(self.agent_registry, 'get_agent', return_value=mock_agent):
            self.mock_client.build_and_send_transaction.return_value = "mock_tx_signature"
            
            updates = {
                "name": "Completely New Name",
                "description": "Completely new description",
                "metadata_uri": "https://newmetadata.example.com/agent.json"
            }
            
            result = await self.agent_registry.update_agent(
                agent_id="test_agent",
                owner=self.owner_keypair,
                updates=updates
            )
            
            assert result == "mock_tx_signature"